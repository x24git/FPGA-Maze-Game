# FPGA-Maze-Game
Xilinx Nexys4 FPGA Maze game

The design can be understood as having a main module Maze which takes in the inputs from the board (clock, switches, button inputs) and outputs to the board the necessary values that need to be adjusted during runtime (anodes, cathodes, vga colors, vga sync). The main module then splits up each of these tasks to 4 specific submodules in order to adjust values accordingly and provide a modular design. These submodules are the display, maze_selector, player_logic, and score with the display module having its own submodule, hvsync_generator. 

Within the maze module, in addition to calling the submodules, we have the player position constantly getting updated to allow other submodules to have their inputs changed as the player moves. The maze module also handles the specific clock timing for the VGA display utilizing a buffer value. 

The first submodule is the maze selector module. The module takes in the selector using the switches and the send corresponding to the reset button while outputting the flattened maze, the player start, and the player end positions. This is where all mazes are stored as a two-dimensional 20x20 maze which is then flattened into a 400 length one-dimensional array to be exported to other submodules as issues with attempting to send two-dimensional arrays occurred. Each maze contains a player starting point and ending point which are used to determine the location the player starts and the end of the maze which is colored differently and used to determine whether the player has won. All mazes are stored as their 20x20 counterparts to simplify and easily interpret what the maze will actually look like and does not have efficiency reasons, but rather understandability value. All mazes are then flattened expending the two-dimensional array into its one-dimensional counterpart. Using the value from the switches, the initial player start is determined and set accordingly and in the event that the reset button is pressed, the selector is also used to set the currently played maze as well as the end of the maze to be sent out to the player logic and display submodules. 

The second submodule is the player logic module. The module takes in the current player position, the flattened maze, the player’s start and end positions, the buttons inputs and the clock while outputting the player’s next position, whether the player has won, if a reset is necessary, or if the player has moved. Using the debouncing method from the previous labs with a 18 bit clock, we recognize the button inputs. The buttons inputs are then applied to a task for movement in which the module determines the players intended position after the given movement, preventing movement into a wall. If the movement is valid, the player’s position is adjusted to the new value and recognize a move has been completed for score updating purposes. If the player’s new position matches the end position of the maze, the module will output that a win has been achieved. 

The next submodule is the score module with decrements the score counter based on time passed and moves used. The module take in the clock, whether a move has been completed, whether a win has been achieved, and whether a reset has been initiated. The module outputs the 7-segment display information (cathodes and anodes). The score system works by using a click divisor for display and another for a 0.25 Hz clock to decrement score based on time. Score is first initialized to 9999 and remains constant until the first move is completed at which point the score start to decrement. The score will also decrement for every move the player makes by 100 points and will continue to decrease through both methods until the score reaches 0 or the player reaches the end, at which point the player will be unable the move and the score will freeze. The method for displaying information to the 7-segment display is similar to previous labs and follows the concept of using a display clock to choose which anode to adjust and using the values of that digits position to set the cathodes accordingly.

The final submodule is the display module which outputs through the VGA port to the computer screen. The display module takes in a 28 bit clock, the flattened maze, the player position, the end of the maze, and whether a reset of win has been initiated. The display then outputs this data as vga green, red, and blue as well as the h_sync and v_sync for the display. The display module first recreates the 20x20 maze from the 400 data array input to make accessing easy to understand. The maze then calculates the X and Y coordinates of the player’s current position, as well as the end of the maze. Using the the current X and Y positions to be displayed generated from the submodule hvsync_generator, the module converts these pixels to finite positions of the maze and compares to the maze and the player. If a value of 1 is encountered within the maze array, the pixel is colored green. If the player is detected within a position, the display uses the color blue while not occupying the whole square as the 1/8th size border remains black around the player. The end of the maze is also colored red. The final feature of the display is that when the player wins (as denoted by the player_logic module) the screen will flash red giving the entire screen a blinking red hue. 

The submodule of the display module, hvsync_generator, generates the necessary updates to the VGA display in order to properly display pixels on the computer screen. Using the clock and reset, the module simply increments counter X every clock cycle unless reaching the end of the X coordinates where by it will reset back to 0. When this value of X reaches its maximum value, the counter Y value will then be incremented until it reaches its maximum value and be reset to 0. The h_sync and v_sync are generated by checking whether the value of Counter X and counter Y are within the specified ranges to be displayed. If these values are outside their ranges, the sync signal is sent and the display will update accordingly. This module referenced code from a source online which dealt with displaying to the FPGA board and can be founder under the user dcarr622 on github. We initially tried to implement the VGA display on our own but struggled to produce the necessary clock timing to produce an accurate display, and by referencing the use of a buffer found in our Maze module as well as basing our counters on this code were we able to produce an appropriate output to the VGA board that works as intended. 

Figure 1. RTL Schematic of the Maze module and its respective submodules.
